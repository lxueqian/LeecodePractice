1. 说起数组就要想到： 双指针/额外数组记录 (考虑需不需要排序）
2. 寻找数组中心索引：一般相加为定值的条件的要记得转换成减法的等式判断条件
3. 至少是其他数字两倍的最大数：if all( max>x*2 for x in nums if x!=m)
4. 加一: 
   通过int和str之间的转换求解 .join()
   或者 for i in range(len(digits)-1,-1,-1) 倒序遍历列表 一定要记住这个range里面的规则！！！！ 然后注意空列表和类似[9]的情况，当遍历到列表第一个值
   一定要判断一下还有没有进位（dividee/modee)
5. 对角线遍历
   找规律
6. 最长公共前缀 o(kn) 正常遍历
7. 反转字符串 [::-1]    列表字典字符串的基本方法一定要掌握！！！！！
8. 数组和字符串的双指针技巧！！！
   1) 从两端向中间迭代数组。
      这时你可以使用双指针技巧：一个指针从始端开始，而另一个指针从末端开始。值得注意的是，这种技巧经常在排序数组中使用
   2) 同时有一个慢指针和一个快指针。
      解决这类问题的关键是确定两个指针的移动策略。有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。
      例子：给定一个数组和一个值，原地删除该值的所有实例并返回新的长度
           相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置
           使用两个指针，一个快指针 i 和一个慢指针 k ，i 每次移动一步，而 k 只在添加新的被需要的值时才移动一步

9. 前缀树
   在字符串数据集中高效检索字符串
   与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 O(m)的时间复杂度，其中m为键长。而在平衡树中查找键
   值需要 O(mlogn) 时间复杂度
   
   Trie，又经常叫前缀树，字典树等等。它有很多变种，如后缀树，Radix Tree/Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。
   定义
   在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由
   节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，
   只有叶子节点和部分内部节点所对应的键才有相关的值。
   trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie
   中的键是一串位元，可以用于表示整数或者内存地址
   
   基本性质
   1，根节点不包含字符，除根节点意外每个节点只包含一个字符。
   2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
   3，每个节点的所有子节点包含的字符串不相同。
   优点：
   可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。
　 跟哈希表比较：
    1，最坏情况时间复杂度比hash表好
    2，没有冲突，除非一个key对应多个值（除key外的其他信息）
    3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。
   缺点：
   1，虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。
      每个结点的子树的根节点的组织方式有几种。1>如果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。
         2>如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。3>alphabet reduction: 减少字符宽度以减少字母集个数
         4>对字符集使用bitmap，再配合链接法。
   2，如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。
   3，长的浮点数等会让链变得很长。可用bitwise trie改进。
10. 字符串: 额外的字典和指针，字符串自己的方法 “”.join(list(filter(str.isalnum,s.lower())))
11. 堆排序
   堆是一种非线性结构，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护
   的一维数组
   按照堆的特点可以把堆分为大顶堆和小顶堆
   大顶堆：每个结点的值都大于或等于其左右孩子结点的值
   小顶堆：每个结点的值都小于或等于其左右孩子结点的值
   （堆的这种特性非常的有用，堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素）
12. 堆与普通树的区别
   搜索：
   在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入
   、删除操作
   平衡：
   二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(nlog2n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实
   际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(nlog2n) 的性能
   内存占用：
   普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额外的内存。堆仅仅使用数组，且不使用指针
13.TopN问题
   Top N问题在搜索引擎、推荐系统领域应用很广， 如果用我们较为常见的语言，如C、C++、Java等，代码量至少也得五行，但是用Python的话，只用一个函数就能搞
   定，只需引入heapq(堆队列)这个数据结构即可
   基于我们建好的小根堆，可以将需要筛选的元素依次与堆顶元素进行比较，若比堆顶大，则置换堆顶，然后对堆进行调整，我们可以得到序列中前N条最大的记录
14.双端队列
   滑动窗口最大值
   双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。
   与队列相似，我们可以利用一个双链表实现双端队列。双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目
   里都有运用
15.计数排序 o(n) 利用额外数组，位置表示数，值表示出现次数
   将数组长度定为max-min+1，即不仅要找出最大值，还要找出最小值，根据两者的差来确定计数数组的长度
   
   
1. 哈希表的关键思想是使用哈希函数将键映射到存储桶。更确切地说，
   当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；
   当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。
   哈希表是一种数据结构，它使用哈希函数组织数据，以支持快速插入和搜索
2. 设计哈希表
   散列函数将取决于键值的范围和桶的数量
   哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射
   插入和搜索是哈希表中的两个基本操作。
   此外，还有基于这两个操作的操作。例如，当我们删除元素时，我们将首先搜索元素，然后在元素存在的情况下从相应位置移除元素
3. 哈希表和哈希映射
   哈希表是一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。
   有两种不同类型的哈希表：哈希集合和哈希映射。
   哈希集合是集合数据结构的实现之一，用于存储非重复值。
   哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。
4. 这里有一些为你准备的关于如何设计键的建议。
   当字符串 / 数组中每个元素的顺序不重要时，可以使用排序后的字符串 / 数组作为键。
   如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。
   在树中，你有时可能会希望直接使用 TreeNode 作为键。 但在大多数情况下，采用子树的序列化表述可能是一个更好的主意。---深度优先搜索
   在矩阵中，你可能希望使用行索引或列索引作为键。
   在数独中，可以将行索引和列索引组合来标识此元素属于哪个块。
   有时，在矩阵中，您可能希望将值聚合在同一对角线中。   
