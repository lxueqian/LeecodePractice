1. 说起数组就要想到： 双指针/额外数组记录 (考虑需不需要排序）
2. 寻找数组中心索引：一般相加为定值的条件的要记得转换成减法的等式判断条件
3. 至少是其他数字两倍的最大数：if all( max>x*2 for x in nums if x!=m)
4. 加一: 
   通过int和str之间的转换求解 .join()
   或者 for i in range(len(digits)-1,-1,-1) 倒序遍历列表 一定要记住这个range里面的规则！！！！ 然后注意空列表和类似[9]的情况，当遍历到列表第一个值
   一定要判断一下还有没有进位（dividee/modee)
5. 对角线遍历
   找规律
6. 最长公共前缀 o(kn) 正常遍历
7. 反转字符串 [::-1]    列表字典字符串的基本方法一定要掌握！！！！！
8. 数组和字符串的双指针技巧！！！
   1) 从两端向中间迭代数组。
      这时你可以使用双指针技巧：一个指针从始端开始，而另一个指针从末端开始。值得注意的是，这种技巧经常在排序数组中使用
   2) 同时有一个慢指针和一个快指针。
      解决这类问题的关键是确定两个指针的移动策略。有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。
      例子：给定一个数组和一个值，原地删除该值的所有实例并返回新的长度
           相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置
           使用两个指针，一个快指针 i 和一个慢指针 k ，i 每次移动一步，而 k 只在添加新的被需要的值时才移动一步

9. 前缀树
   在字符串数据集中高效检索字符串
   与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 O(m)的时间复杂度，其中m为键长。而在平衡树中查找键
   值需要 O(mlogn) 时间复杂度
   
   Trie，又经常叫前缀树，字典树等等。它有很多变种，如后缀树，Radix Tree/Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。
   定义
   在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由
   节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，
   只有叶子节点和部分内部节点所对应的键才有相关的值。
   trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie
   中的键是一串位元，可以用于表示整数或者内存地址
   
   基本性质
   1，根节点不包含字符，除根节点意外每个节点只包含一个字符。
   2，从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
   3，每个节点的所有子节点包含的字符串不相同。
   优点：
   可以最大限度地减少无谓的字符串比较，故可以用于词频统计和大量字符串排序。
　 跟哈希表比较：
    1，最坏情况时间复杂度比hash表好
    2，没有冲突，除非一个key对应多个值（除key外的其他信息）
    3，自带排序功能（类似Radix Sort），中序遍历trie可以得到排序。
   缺点：
   1，虽然不同单词共享前缀，但其实trie是一个以空间换时间的算法。其每一个字符都可能包含至多字符集大小数目的指针（不包含卫星数据）。
      每个结点的子树的根节点的组织方式有几种。1>如果默认包含所有字符集，则查找速度快但浪费空间（特别是靠近树底部叶子）。
         2>如果用链接法(如左儿子右兄弟)，则节省空间但查找需顺序（部分）遍历链表。3>alphabet reduction: 减少字符宽度以减少字母集个数
         4>对字符集使用bitmap，再配合链接法。
   2，如果数据存储在外部存储器等较慢位置，Trie会较hash速度慢（hash访问O(1)次外存，Trie访问O(树高)）。
   3，长的浮点数等会让链变得很长。可用bitwise trie改进。
10. 字符串: 额外的字典和指针，字符串自己的方法 “”.join(list(filter(str.isalnum,s.lower())))
11. 堆排序
   堆是一种非线性结构，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护
   的一维数组
   按照堆的特点可以把堆分为大顶堆和小顶堆
   大顶堆：每个结点的值都大于或等于其左右孩子结点的值
   小顶堆：每个结点的值都小于或等于其左右孩子结点的值
   （堆的这种特性非常的有用，堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素）
12. 堆与普通树的区别
   搜索：
   在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入
   、删除操作
   平衡：
   二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(nlog2n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实
   际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(nlog2n) 的性能
   内存占用：
   普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额外的内存。堆仅仅使用数组，且不使用指针
13.TopN问题
   Top N问题在搜索引擎、推荐系统领域应用很广， 如果用我们较为常见的语言，如C、C++、Java等，代码量至少也得五行，但是用Python的话，只用一个函数就能搞
   定，只需引入heapq(堆队列)这个数据结构即可
   基于我们建好的小根堆，可以将需要筛选的元素依次与堆顶元素进行比较，若比堆顶大，则置换堆顶，然后对堆进行调整，我们可以得到序列中前N条最大的记录
14.双端队列
   滑动窗口最大值
   双端队列和普通队列最大的不同在于，它允许我们在队列的头尾两端都能在 O(1) 的时间内进行数据的查看、添加和删除。
   与队列相似，我们可以利用一个双链表实现双端队列。双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目
   里都有运用
15.计数排序 o(n) 利用额外数组，位置表示数，值表示出现次数
   将数组长度定为max-min+1，即不仅要找出最大值，还要找出最小值，根据两者的差来确定计数数组的长度

   
